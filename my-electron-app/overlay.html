<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Overlay Window</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background: transparent; /* 완전히 투명 */
        font-family: sans-serif;
        color: #fff;
        -webkit-app-region: drag;
        overflow: hidden;
      }
      /* 물고기 이미지 스타일 */
      .fish {
        object-fit: contain;
        position: absolute;
      }
    </style>
    <!-- GSAP CDN (최신 버전으로 업데이트 가능) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.5/gsap.min.js"></script>
  </head>
  <body>
    <script>
      window.addEventListener("DOMContentLoaded", () => {
        // overlay-preload.js를 통해 expose된 overlayAPI를 사용해 fishData를 받음
        window.overlayAPI.onFishData((dataStr) => {
          // console.log('[overlay.html] onFishData - fishDataStr:', fishDataStr);
          if (!dataStr) {
            console.warn("[overlay.html] 전달받은 dataStr이 없습니다.");
            return;
          }
          // 데이터 포맷: "fishDataPart|transparency"
          // 예시: "https://example.com/fish1.png:S:2,https://example.com/fish2.png:M:1|50"
          const parts = dataStr.split("|");
          if (parts.length !== 2) {
            console.warn("[overlay.html] 잘못된 데이터 포맷:", dataStr);
            return;
          }
          const fishDataPart = parts[0];
          const transparency = parseInt(parts[1], 10); // 0~100 사이의 값

          const fishEntries = fishDataPart.split(",");
          fishEntries.forEach((entry) => {
            const parts = entry.split(":");
            // console.log('parts.length:', parts.length);
            if (parts.length !== 4) {
              console.warn("[overlay.html] 잘못된 데이터 포맷:", entry);
              return;
            }
            const [head, imgUrl, size, countStr] = parts;
            const count = parseInt(countStr, 10);
            for (let i = 0; i < count; i++) {
              createFish(head + ":" + imgUrl, size, transparency);
            }
          });
        });
      });

      // 물고기 크기 설정 함수
      function getFishSize(size) {
        switch (size) {
          case "XS":
            return { width: 50, height: 50 };
          case "S":
            return { width: 75, height: 75 };
          case "M":
            return { width: 110, height: 110 };
          case "L":
            return { width: 175, height: 175 };
          case "XL":
            return { width: 200, height: 200 };
          default:
            return { width: 110, height: 110 }; // 기본값 (M)
        }
      }

      // 물고기 이미지 생성 및 DOM에 추가
      function createFish(imgUrl, size, transparency) {
        const fishImg = document.createElement("img");
        fishImg.className = "fish";
        fishImg.src = imgUrl;
        fishImg.alt = "fish image";

        // 크기 적용
        const fishSize = getFishSize(size);
        fishImg.style.width = fishSize.width + "px";
        fishImg.style.height = fishSize.height + "px";

        // 전달받은 투명도(0~100)를 0~1로 변환하여 적용
        fishImg.style.opacity = transparency / 100;

        document.body.appendChild(fishImg);
        fishImg.onload = () => {
          animateFish(fishImg);
        };
      }

      // 기존 애니메이션 효과를 그대로 사용하여 물고기 움직임 구현
      function animateFish(element) {
        const width = window.innerWidth;
        const height = window.innerHeight;
        const fishWidth = 150; // 이미지 크기 기준 (안내용)
        const safeMargin = (fishWidth - 70) / 2 + 90; // 약 130px
        const bottomMargin = 100;
        const upperLimit = height * 0.2;

        // 초기 위치를 무작위로 설정
        let startX = Math.random() * (width - 2 * safeMargin) + safeMargin;
        let startY = Math.random() * (height - bottomMargin - 50) + 50;
        gsap.set(element, { x: startX, y: startY, scaleX: -1 });

        let direction = 1; // 1 또는 -1

        function moveFish() {
          const randomSpeed = Math.random() * 7 + 9; // 9 ~ 16초 사이의 이동 시간
          const maxMoveX = width * (0.4 + Math.random() * 0.4);
          let moveDistanceX = maxMoveX * (Math.random() > 0.5 ? 1 : -1);
          const currentY = parseFloat(gsap.getProperty(element, "y"));
          let moveDistanceY =
            height *
            (0.1 + Math.random() * 0.15) *
            (Math.random() > 0.65 ? 1 : -1);

          // 상단 경계에 너무 근접하면 아래로 이동하도록 조정
          if (currentY < upperLimit) {
            moveDistanceY = height * (0.1 + Math.random() * 0.2);
          }

          let currentX = parseFloat(gsap.getProperty(element, "x"));
          let newX = currentX + moveDistanceX;
          let newY = currentY + moveDistanceY;

          // 좌측/우측 경계 체크 및 조정
          if (newX < safeMargin) {
            newX = safeMargin;
            moveDistanceX = Math.abs(moveDistanceX);
          }
          if (newX > width - safeMargin) {
            newX = width - safeMargin;
            moveDistanceX = -Math.abs(moveDistanceX);
          }
          // 상단/하단 경계 체크
          if (newY < 50) {
            newY = 50 + Math.random() * 30;
          }
          if (newY > height - bottomMargin) {
            newY = height - bottomMargin - Math.random() * 30;
          }

          // 이동 방향에 따라 이미지 반전 (scaleX)
          direction = moveDistanceX > 0 ? -1 : 1;

          gsap.to(element, {
            x: newX,
            y: newY,
            scaleX: direction,
            duration: randomSpeed,
            ease: "power2.inOut",
            onUpdate: function () {
              const prevX = parseFloat(gsap.getProperty(element, "x"));
              direction = newX > prevX ? -1 : 1;
              gsap.set(element, { scaleX: direction });
            },
            onComplete: moveFish,
          });
        }

        moveFish();
      }
    </script>
  </body>
</html>
