<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Overlay Window</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background: transparent; /* 완전히 투명 */
        font-family: sans-serif;
        color: #fff;
        -webkit-app-region: drag;
        overflow: hidden;
      }
      /* 물고기 이미지 스타일 */
      #fishImg {
        width: 75px;
        height: 75px;
        object-fit: contain;
        position: absolute;
      }
    </style>
    <!-- GSAP CDN (최신 버전으로 업데이트 가능) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.5/gsap.min.js"></script>
  </head>
  <body>
    <img id="fishImg" src="" alt="fish image" />
    <script>
      // overlay-preload.js를 통해 expose된 overlayAPI를 사용해 fishPath를 받음
      window.overlayAPI.onFishData((fishPath) => {
        console.log('[overlay.html] onFishData - fishPath:', fishPath);
        const fishImg = document.getElementById('fishImg');
        fishImg.src = fishPath;
        // 이미지가 로드되면 애니메이션 시작
        fishImg.onload = () => {
          animateFish(fishImg);
        };
      });

      // 자연스러운 물고기 움직임을 위한 애니메이션 함수
      function animateFish(element) {
        const width = window.innerWidth;
        const height = window.innerHeight;
        const fishWidth = 150; // 이미지 크기
        const fishHeight = 150;
        // Next.js 코드의 safeMargin 계산식을 참고 (여기서는 150px 기준)
        const safeMargin = (fishWidth - 70) / 2 + 90; // 약 130px
        const bottomMargin = 100;
        const upperLimit = height * 0.2;

        // 초기 위치: 좌우 경계를 고려하여 safeMargin 내에서 배치
        let startX = Math.random() * (width - 2 * safeMargin) + safeMargin;
        let startY = Math.random() * (height - bottomMargin - 50) + 50;
        gsap.set(element, { x: startX, y: startY, scaleX: -1 });

        let direction = 1; // 1 또는 -1 (이미지 좌우 반전)

        function moveFish() {
          const randomSpeed = Math.random() * 7 + 9; // 9 ~ 16초 사이의 이동 시간
          const maxMoveX = width * (0.4 + Math.random() * 0.4);
          let moveDistanceX = maxMoveX * (Math.random() > 0.5 ? 1 : -1);
          const currentY = parseFloat(gsap.getProperty(element, 'y'));
          let moveDistanceY =
            height *
            (0.1 + Math.random() * 0.15) *
            (Math.random() > 0.65 ? 1 : -1);

          // 상단 경계에 너무 근접하면 아래로 이동하도록 조정
          if (currentY < upperLimit) {
            moveDistanceY = height * (0.1 + Math.random() * 0.2);
          }

          let currentX = parseFloat(gsap.getProperty(element, 'x'));
          let newX = currentX + moveDistanceX;
          let newY = currentY + moveDistanceY;

          // 좌측/우측 경계 체크 및 조정
          if (newX < safeMargin) {
            newX = safeMargin;
            moveDistanceX = Math.abs(moveDistanceX);
          }
          if (newX > width - safeMargin) {
            newX = width - safeMargin;
            moveDistanceX = -Math.abs(moveDistanceX);
          }
          // 상단/하단 경계 체크
          if (newY < 50) {
            newY = 50 + Math.random() * 30;
          }
          if (newY > height - bottomMargin) {
            newY = height - bottomMargin - Math.random() * 30;
          }

          // 이동 방향에 따라 이미지 반전 (scaleX)
          direction = moveDistanceX > 0 ? -1 : 1;

          gsap.to(element, {
            x: newX,
            y: newY,
            scaleX: direction,
            duration: randomSpeed,
            ease: 'power2.inOut',
            onUpdate: function () {
              // 이동 중에도 계속 방향 업데이트
              const prevX = parseFloat(gsap.getProperty(element, 'x'));
              direction = newX > prevX ? -1 : 1;
              gsap.set(element, { scaleX: direction });
            },
            onComplete: moveFish,
          });
        }

        moveFish();
      }
    </script>
  </body>
</html>
